(declare-sort time 0)
(declare-sort index 0)
(declare-fun new_q1.trying.now () Bool)
(declare-fun |__ts0__new_fml:val| () time)
(declare-fun |__loc:y| () time)
(declare-fun new_q1.pending () (Array time Bool))
(declare-fun q1.receiving.value () time)
(declare-fun |0:index| () index)
(declare-fun |__fml:x| () time)
(declare-fun _X () time)
(declare-fun new_.r () Bool)
(declare-fun __m_.r_a () Bool)
(declare-fun __ts0_b () Bool)
(declare-fun time.succ (time time) Bool)
(declare-fun new_q1.sending.now () Bool)
(declare-fun q1.test_fun () (Array time (Array time Bool)))
(declare-fun q1.sending.value () time)
(declare-fun __ts0__m_q1.receiving.now () Bool)
(declare-fun new_q1.test_fun () (Array time (Array time Bool)))
(declare-fun index.succ (index index) Bool)
(declare-fun __ts0_a () Bool)
(declare-fun q1.sending.now () Bool)
(declare-fun q1.receiving.now () Bool)
(declare-fun __m_q1.trying.now () Bool)
(declare-fun |<:time:time| (time time) Bool)
(declare-fun |<:index:index| (index index) Bool)
(declare-fun |0:time| () time)
(declare-fun q1.pending () (Array time Bool))
(declare-fun q1.trying.now () Bool)
(declare-fun __m_q1.sending.now () Bool)
(declare-fun new_q1.sending.value () time)
(declare-fun __m_.r () Bool)
(declare-fun new_q1.receiving.now () Bool)
(declare-fun |__new_fml:val| () time)
(declare-fun new_q1.receiving.value () time)
(declare-fun .r () Bool)
(define-fun .q1.trying.now () Bool (! q1.trying.now :next new_q1.trying.now))
(declare-fun new___ts0__new_fmlval () time)
(define-fun .__ts0__new_fmlval () time (! |__ts0__new_fml:val| :next new___ts0__new_fmlval))
(declare-fun new___locy () time)
(define-fun .__locy () time (! |__loc:y| :next new___locy))
(define-fun .q1.pending () (Array time Bool) (! q1.pending :next new_q1.pending))
(declare-fun new___fmlx () time)
(define-fun .__fmlx () time (! |__fml:x| :next new___fmlx))
(define-fun ..r () Bool (! .r :next new_.r))
(declare-fun new___m_.r_a () Bool)
(define-fun .__m_.r_a () Bool (! __m_.r_a :next new___m_.r_a))
(declare-fun new___ts0_b () Bool)
(define-fun .__ts0_b () Bool (! __ts0_b :next new___ts0_b))
(define-fun .q1.sending.now () Bool (! q1.sending.now :next new_q1.sending.now))
(declare-fun new___ts0__m_q1.receiving.now () Bool)
(define-fun .__ts0__m_q1.receiving.now () Bool (! __ts0__m_q1.receiving.now :next new___ts0__m_q1.receiving.now))
(define-fun .q1.test_fun () (Array time (Array time Bool)) (! q1.test_fun :next new_q1.test_fun))
(declare-fun new___ts0_a () Bool)
(define-fun .__ts0_a () Bool (! __ts0_a :next new___ts0_a))
(declare-fun new___m_q1.trying.now () Bool)
(define-fun .__m_q1.trying.now () Bool (! __m_q1.trying.now :next new___m_q1.trying.now))
(declare-fun new___m_q1.sending.now () Bool)
(define-fun .__m_q1.sending.now () Bool (! __m_q1.sending.now :next new___m_q1.sending.now))
(define-fun .q1.sending.value () time (! q1.sending.value :next new_q1.sending.value))
(declare-fun new___m_.r () Bool)
(define-fun .__m_.r () Bool (! __m_.r :next new___m_.r))
(define-fun .q1.receiving.now () Bool (! q1.receiving.now :next new_q1.receiving.now))
(declare-fun new___new_fmlval () time)
(define-fun .__new_fmlval () time (! |__new_fml:val| :next new___new_fmlval))
(define-fun .q1.receiving.value () time (! q1.receiving.value :next new_q1.receiving.value))
(declare-fun _idle () Bool)
(define-fun ._idle () Bool (! _idle :action 0))
(declare-fun q1.recv () Bool)
(define-fun .q1.recv () Bool (! q1.recv :action 0))
(declare-fun q1.send () Bool)
(define-fun .q1.send () Bool (! q1.send :action 0))
(define-fun init () Bool (! (and (not .r)
     (= q1.pending ((as const (Array time Bool)) false))
     (= q1.test_fun
        ((as const (Array time (Array time Bool)))
          ((as const (Array time Bool)) false)))
     (not q1.sending.now)
     (not q1.trying.now)
     (not q1.receiving.now)) :init true))
(define-fun trans () Bool (! (and (=> _idle (and (not new_.r)
     (= q1.trying.now new_q1.trying.now)
     (= q1.pending new_q1.pending)
     (= q1.receiving.value new_q1.receiving.value)
     (= q1.receiving.now new_q1.receiving.now)
     (= q1.test_fun new_q1.test_fun)
     (= q1.sending.value new_q1.sending.value)
     (= q1.sending.now new_q1.sending.now)))
(=> q1.recv (let ((a!1 (forall ((|V0:time| time))
             (or (not __ts0_b) (not (select q1.pending |V0:time|))))))
  (and (not __m_.r_a)
       __m_q1.trying.now
       (= __m_.r (or __m_.r_a __m_q1.trying.now))
       (not new_q1.trying.now)
       (= new_.r (or __m_.r new_q1.trying.now))
       (= new_q1.pending
          (ite __ts0_b q1.pending (store q1.pending |__loc:y| false)))
       (= |__ts0__new_fml:val| |__loc:y|)
       (= new_q1.receiving.value
          (ite __ts0_b q1.receiving.value |__ts0__new_fml:val|))
       __ts0__m_q1.receiving.now
       (= new_q1.receiving.now (and __ts0_b q1.receiving.now))
       (= q1.test_fun new_q1.test_fun)
       (= q1.sending.value new_q1.sending.value)
       (= q1.sending.now new_q1.sending.now)
       (or __ts0_a __ts0_b)
       (or (not __ts0_a) (select q1.pending |__loc:y|))
       (forall ((|V0:time| time))
         (let ((a!1 (not (and (select q1.pending |V0:time|)
                              (or (= |V0:time| |__loc:y|)
                                  (|<:time:time| |V0:time| |__loc:y|))
                              (not (= |V0:time| |__loc:y|))))))
           (or (not __ts0_a) a!1)))
       a!1)))
(=> q1.send (let ((a!1 (forall ((|T:time| time))
             (or (not (select q1.pending |T:time|))
                 (|<:time:time| |T:time| |__fml:x|)))))
  (and (not new_.r)
       (= new_q1.pending (store q1.pending |__fml:x| true))
       (= new_q1.test_fun
          (store q1.test_fun |__fml:x| ((as const (Array time Bool)) true)))
       (= |__new_fml:val| |__fml:x|)
       (= new_q1.sending.value |__new_fml:val|)
       __m_q1.sending.now
       (not new_q1.sending.now)
       (= q1.trying.now new_q1.trying.now)
       (= q1.receiving.value new_q1.receiving.value)
       (= q1.receiving.now new_q1.receiving.now)
       a!1)))
(or _idle q1.recv q1.send)
(or (not _idle) (not q1.recv))
(or (not _idle) (not q1.send))
(or (not q1.recv) (not q1.send))) :trans true))
(assert (forall ((|X:index| index) (|Y:index| index) (|Z:index| index))
  (let ((a!1 (and (|<:index:index| |X:index| |Z:index|)
                  (not (and (|<:index:index| |X:index| |Y:index|)
                            (|<:index:index| |Y:index| |Z:index|))))))
    (or (not (index.succ |X:index| |Z:index|)) a!1))))
(assert (forall ((|T:index| index) (|U:index| index) (|V:index| index))
  (or (not (and (|<:index:index| |T:index| |U:index|)
                (|<:index:index| |U:index| |V:index|)))
      (|<:index:index| |T:index| |V:index|))))
(assert (forall ((|T:index| index) (|U:index| index))
  (not (and (|<:index:index| |T:index| |U:index|)
            (|<:index:index| |U:index| |T:index|)))))
(assert (forall ((|T:index| index) (|U:index| index))
  (or (|<:index:index| |T:index| |U:index|)
      (= |T:index| |U:index|)
      (|<:index:index| |U:index| |T:index|))))
(assert (forall ((|X:index| index))
  (or (= |0:index| |X:index|) (|<:index:index| |0:index| |X:index|))))
(assert (forall ((|X:time| time) (|Y:time| time) (|Z:time| time))
  (let ((a!1 (and (|<:time:time| |X:time| |Z:time|)
                  (not (and (|<:time:time| |X:time| |Y:time|)
                            (|<:time:time| |Y:time| |Z:time|))))))
    (or (not (time.succ |X:time| |Z:time|)) a!1))))
(assert (forall ((|T:time| time) (|U:time| time) (|V:time| time))
  (or (not (and (|<:time:time| |T:time| |U:time|)
                (|<:time:time| |U:time| |V:time|)))
      (|<:time:time| |T:time| |V:time|))))
(assert (forall ((|T:time| time) (|U:time| time))
  (not (and (|<:time:time| |T:time| |U:time|) (|<:time:time| |U:time| |T:time|)))))
(assert (forall ((|T:time| time) (|U:time| time))
  (or (|<:time:time| |T:time| |U:time|)
      (= |T:time| |U:time|)
      (|<:time:time| |U:time| |T:time|))))
(assert (forall ((|X:time| time))
  (or (= |0:time| |X:time|) (|<:time:time| |0:time| |X:time|))))
(define-fun .p () Bool (! (and q1.sending.now (= q1.sending.value _X)) :react_p true))
(define-fun .q () Bool (! (and q1.receiving.now (= q1.receiving.value _X)) :react_q true))
(define-fun .r () Bool (! q1.trying.now :react_r true))
