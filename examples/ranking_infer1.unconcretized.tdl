(sort time)

(parameter-var _X time)
(fun |<:time:time| (-> (time time) Bool))
(var |0:time| time)

(transition-var |__ts0__new_fml:val| time)
(transition-var |__loc:y| time)
(transition-var |__fml:x| time)
(transition-var __ts0_b Bool)
(transition-var __ts0__m_q1.receiving.now Bool)
(transition-var __ts0_a Bool)
(transition-var __m_q1.trying.now Bool)
(transition-var __m_q1.sending.now Bool)
(transition-var __m_.r Bool)
(transition-var |__new_fml:val| time)

(state-var q1.pending (Array time Bool) :next new_q1.pending)
(state-var .r Bool :next new_.r)
(state-var q1.sending.now Bool :next new_q1.sending.now)
(state-var q1.sending.value time :next new_q1.sending.value)
(state-var q1.receiving.now Bool :next new_q1.receiving.now)
(state-var q1.receiving.value time :next new_q1.receiving.value)

(init
  (and (not .r)
       (= q1.pending ((as const (Array time Bool)) false))
       (not q1.sending.now)
       (not q1.receiving.now)))

(transition 
  (and (not new_.r)
             (= q1.pending new_q1.pending)
             (= q1.receiving.value new_q1.receiving.value)
             (not new_q1.receiving.now)
             (= q1.sending.value new_q1.sending.value)
             (not new_q1.sending.now)) 
  :name _idle)

(transition
  (let ((a!1 (forall ((|V0:time| time))
                     (or (not __ts0_b)
                         (not (select q1.pending |V0:time|))))))
          (and __m_q1.trying.now
               (= __m_.r __m_q1.trying.now)
               (= new_.r __m_.r)
               (= new_q1.pending
                  (ite __ts0_b q1.pending
                       (store q1.pending |__loc:y| false)))
               (= |__ts0__new_fml:val| |__loc:y|)
               (= new_q1.receiving.value
                  (ite __ts0_b q1.receiving.value
                       |__ts0__new_fml:val|))
               __ts0__m_q1.receiving.now
               (= new_q1.receiving.now (and __ts0_a __ts0__m_q1.receiving.now))
               (= q1.sending.value new_q1.sending.value)
               (not new_q1.sending.now)
               (or __ts0_a __ts0_b)
               (or (not __ts0_a) (select q1.pending |__loc:y|))
               (forall ((|V0:time| time))
                 (let ((a!1 (not (and (select q1.pending |V0:time|)
                                      (or (= |V0:time| |__loc:y|)
                                          (|<:time:time| |V0:time| |__loc:y|))
                                      (not (= |V0:time| |__loc:y|))))))
                   (or (not __ts0_a) a!1)))
               a!1)) 
    :name q1.recv)
(transition
  (let ((a!1 (forall ((|T:time| time))
                     (or (not (select q1.pending |T:time|))
                         (|<:time:time| |T:time| |__fml:x|)))))
          (and (not new_.r)
               (= new_q1.pending (store q1.pending |__fml:x| true))
               (= |__new_fml:val| |__fml:x|)
               (= new_q1.sending.value |__new_fml:val|)
               __m_q1.sending.now
               (= new_q1.sending.now __m_q1.sending.now)
               (= q1.receiving.value new_q1.receiving.value)
               (not new_q1.receiving.now)
               a!1)) 
  :name q1.send)

(theory-axiom
  (forall ((|T:time| time) (|U:time| time) (|V:time| time))
    (or (not (and (|<:time:time| |T:time| |U:time|)
                  (|<:time:time| |U:time| |V:time|)))
        (|<:time:time| |T:time| |V:time|))))

(theory-axiom
  (forall ((|T:time| time) (|U:time| time))
    (not (and (|<:time:time| |T:time| |U:time|)
              (|<:time:time| |U:time| |T:time|)))))

(theory-axiom
  (forall ((|T:time| time) (|U:time| time))
    (or (|<:time:time| |T:time| |U:time|)
        (= |T:time| |U:time|)
        (|<:time:time| |U:time| |T:time|))))

(theory-axiom
  (forall ((|X:time| time))
    (or (= |0:time| |X:time|)
        (|<:time:time| |0:time| |X:time|))))

(live-property
  (and q1.receiving.now
       (= q1.receiving.value _X))
  :name live0)

(live-assumption
 (and q1.sending.now (= q1.sending.value _X)) :name live0)

(fair-assumption
  .r
  :name live0)
