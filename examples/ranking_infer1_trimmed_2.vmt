(declare-sort (! time :finite 3))
(declare-fun new_q1.trying.now () Bool)
(declare-fun (! |__ts0__new_fml:val| () time :transition-variable))
(declare-fun (! |__loc:y| () time :transition-variable))
(declare-fun new_q1.pending () (Array time Bool))
(declare-fun q1.receiving.value () time)
(declare-fun (! |__fml:x| () time :transition-variable))
(declare-fun _X () time)
(declare-fun (! __m_.r_a () Bool :transition-variable))
(declare-fun (! __ts0_b () Bool :transition-variable))
(declare-fun new_q1.sending.now () Bool)
(declare-fun q1.sending.value () time)
(declare-fun (! __ts0__m_q1.receiving.now () Bool :transition-variable))
(declare-fun (! __ts0_a () Bool :transition-variable))
(declare-fun q1.sending.now () Bool)
(declare-fun q1.receiving.now () Bool)
(declare-fun (! __m_q1.trying.now () Bool :transition-variable))
(declare-fun |<:time:time| (time time) Bool)
(declare-fun |0:time| () time)
(declare-fun q1.pending () (Array time Bool))
(declare-fun q1.trying.now () Bool)
(declare-fun (! __m_q1.sending.now () Bool :transition-variable))
(declare-fun new_q1.sending.value () time)
(declare-fun (! __m_.r () Bool :transition-variable))
(declare-fun new_q1.receiving.now () Bool)
(declare-fun (! |__new_fml:val| () time :transition-variable))
(declare-fun new_q1.receiving.value () time)
(declare-fun .r () Bool)
(declare-fun new_.r () Bool)
(define-fun .q1.trying.now () Bool (! q1.trying.now :next new_q1.trying.now))
(define-fun .q1.pending () (Array time Bool) (! q1.pending :next new_q1.pending))
(define-fun ..r () Bool (! .r :next new_.r))
(define-fun .q1.sending.now () Bool (! q1.sending.now :next new_q1.sending.now))
(define-fun .q1.sending.value () time (! q1.sending.value :next new_q1.sending.value))
(define-fun .q1.receiving.now () Bool (! q1.receiving.now :next new_q1.receiving.now))
(define-fun .q1.receiving.value () time (! q1.receiving.value :next new_q1.receiving.value))
(declare-fun _idle () Bool)
(define-fun ._idle () Bool (! _idle :action 0))
(declare-fun q1.recv () Bool)
(define-fun .q1.recv () Bool (! q1.recv :action 0))
(declare-fun q1.send () Bool)
(define-fun .q1.send () Bool (! q1.send :action 0))
(define-fun init () Bool (! (and (not .r)
     (= q1.pending ((as const (Array time Bool)) false))
     (not q1.sending.now)
     (not q1.trying.now)
     (not q1.receiving.now)) :init true))
(define-fun trans () Bool (! (and (=> _idle (and (not new_.r)
     (= q1.trying.now new_q1.trying.now)
     (= q1.pending new_q1.pending)
     (= q1.receiving.value new_q1.receiving.value)
     (= q1.receiving.now new_q1.receiving.now)
     (= q1.sending.value new_q1.sending.value)
     (= q1.sending.now new_q1.sending.now)))
(=> q1.recv (let ((a!1 (forall ((|V0:time| time))
             (or (not __ts0_b) (not (select q1.pending |V0:time|))))))
  (and (not __m_.r_a)
       __m_q1.trying.now
       (= __m_.r (or __m_.r_a __m_q1.trying.now))
       (not new_q1.trying.now)
       (= new_.r (or __m_.r new_q1.trying.now))
       (= new_q1.pending
          (ite __ts0_b q1.pending (store q1.pending |__loc:y| false)))
       (= |__ts0__new_fml:val| |__loc:y|)
       (= new_q1.receiving.value
          (ite __ts0_b q1.receiving.value |__ts0__new_fml:val|))
       __ts0__m_q1.receiving.now
       (= new_q1.receiving.now (and __ts0_b q1.receiving.now))
       (= q1.sending.value new_q1.sending.value)
       (= q1.sending.now new_q1.sending.now)
       (or __ts0_a __ts0_b)
       (or (not __ts0_a) (select q1.pending |__loc:y|))
       (forall ((|V0:time| time))
         (let ((a!1 (not (and (select q1.pending |V0:time|)
                              (or (= |V0:time| |__loc:y|)
                                  (|<:time:time| |V0:time| |__loc:y|))
                              (not (= |V0:time| |__loc:y|))))))
           (or (not __ts0_a) a!1)))
       a!1)))
(=> q1.send (let ((a!1 (forall ((|T:time| time))
             (or (not (select q1.pending |T:time|))
                 (|<:time:time| |T:time| |__fml:x|)))))
  (and (not new_.r)
       (= new_q1.pending (store q1.pending |__fml:x| true))
       (= |__new_fml:val| |__fml:x|)
       (= new_q1.sending.value |__new_fml:val|)
       __m_q1.sending.now
       (not new_q1.sending.now)
       (= q1.trying.now new_q1.trying.now)
       (= q1.receiving.value new_q1.receiving.value)
       (= q1.receiving.now new_q1.receiving.now)
       a!1)))
(or _idle q1.recv q1.send)
(or (not _idle) (not q1.recv))
(or (not _idle) (not q1.send))
(or (not q1.recv) (not q1.send))) :trans true))
(assert (! (forall ((|T:time| time) (|U:time| time) (|V:time| time))
  (or (not (and (|<:time:time| |T:time| |U:time|)
                (|<:time:time| |U:time| |V:time|)))
      (|<:time:time| |T:time| |V:time|))) :theory-axiom))
(assert (! (forall ((|T:time| time) (|U:time| time))
  (not (and (|<:time:time| |T:time| |U:time|) (|<:time:time| |U:time| |T:time|)))) :theory-axiom))
(assert (! (forall ((|T:time| time) (|U:time| time))
  (or (|<:time:time| |T:time| |U:time|)
      (= |T:time| |U:time|)
      (|<:time:time| |U:time| |T:time|))) :theory-axiom))
(assert (! (forall ((|X:time| time))
  (or (= |0:time| |X:time|) (|<:time:time| |0:time| |X:time|))) :theory-axiom))
(define-fun .p () Bool (! (and q1.sending.now (= q1.sending.value _X)) :react_p true))
(define-fun .q () Bool (! (and q1.receiving.now (= q1.receiving.value _X)) :react_q true))
(define-fun .reactive () Bool (! q1.trying.now :react_r true))
