import sbt.Keys.scalacOptions

ThisBuild / version := "0.1.0"

ThisBuild / scalaVersion := "3.7.4"

libraryDependencies ++= Seq(
  "org.scalacheck" %% "scalacheck" % "1.15.4" % "test",
  "org.scalatestplus" %% "scalacheck-1-18" % "3.2.19.0" % "test",
  "org.scalatest" %% "scalatest" % "3.2.19",
  "org.typelevel" %% "cats-parse" % "1.0.0",
  "org.typelevel" %% "cats-core" % "2.13.0",
  "org.typelevel" %% "cats-laws" % "2.13.0",
  "org.typelevel" %% "algebra" % "2.13.0",
  "org.typelevel" %% "cats-kernel" % "2.13.0",
  "org.typelevel" %% "cats-free" % "2.13.0",
  "org.typelevel" %% "cats-testkit" % "2.13.0",
  "org.typelevel" %% "shapeless3-deriving" % "3.4.0",
  "org.typelevel" %% "shapeless3-typeable" % "3.4.0",
  "com.lihaoyi" % "ammonite_3.6.3" % "3.0.2", //% "test" cross CrossVersion.full,
  "de.uni-freiburg.informatik.ultimate" % "smtinterpol" % "2.5-1388-ga5a4ab0c", // SMTInterpol
  "org.clojure" % "clojure" % "1.12.4", // Clojure for mini-DSL
  //"tools.aqua" % "z3-turnkey" % "4.14.1" ,// Z3-Turnkey: https://github.com/tudo-aqua/z3-turnkey
  "tools.aqua" % "cvc5-turnkey" % "1.2.0", // CVC5-Turnkey: https://github.com/tudo-aqua/cvc5-turnkey
  "org.scala-lang" %% "scala3-staging" % scalaVersion.value // for staged evaluation support
)

// XXX: Ammonite cannot accept stdin if we set run / fork := true.

////////////////

// Detect platform -> choose native dir -> set the right env var (PATH/LD_/DYLD_)
val os   = sys.props.getOrElse("os.name", "").toLowerCase
val arch = sys.props.getOrElse("os.arch", "").toLowerCase

val platform =
  if (os.contains("mac")) {
    if (arch.contains("aarch64") || arch.contains("arm")) "macos-arm64"
    else "macos-x86_64"
  } else {
    "linux-x86_64"
  }


lazy val pPrint = settingKey[Unit]("example")

pPrint := {
  println("\n******* Platform: " + platform + " ****** \n")
  println("\n  LD_LIBRARY_PATH: " + (baseDirectory.value / "lib" / platform).getAbsolutePath + "\n")
  println("\n  DYLD_LIBRARY_PATH: " +  (baseDirectory.value / "lib" /  platform).getAbsolutePath + "\n")
  println("\n***************************************** \n")
}

// CAUTION: To override java.library.path we need to run in fork := true mode.
// But by default in this mode Ammonite console will break, so we also need
// to pipe in stdin via setting connectInput := true.
ThisBuild / fork := true
ThisBuild / connectInput := true

ThisBuild / envVars ++= Map(
  // adjust path to wherever you put the two native libs
  "LD_LIBRARY_PATH" -> (baseDirectory.value / "lib" / platform).getAbsolutePath,
  "DYLD_LIBRARY_PATH" -> (baseDirectory.value / "lib" /  platform).getAbsolutePath,
  "PATH" -> {
    val p = (baseDirectory.value / "lib").getAbsolutePath
    sys.env.get("PATH").fold(p)(old => s"$p${java.io.File.pathSeparator}$old")
  }
)
ThisBuild / javaOptions ++= Seq(
  s"-Djava.library.path=${(baseDirectory.value / "lib" / platform).getAbsolutePath}"
)


///////////////
// AutoRegister trait implementation
lazy val generateRegistry = taskKey[Seq[File]]("Generates the robust annotation registry")

generateRegistry := {
  val sourceDir = (Compile / scalaSource).value
  val targetFile = sourceDir / "tempura" / "cozy" / "Registry.scala"

  // REGEX EXPLANATION:
  // (?s)                -> Dot-all mode: allow . to match newlines
  // @AutoRegister\s*\(  -> Match annotation name and open paren with optional space
  // \s*"([^"]+)"\s* -> Capture the name string, ignoring spaces around it
  // \)                  -> Closing paren
  // (?:[\s\w@\(\)."]*?) -> NON-GREEDY: Match any whitespace, words, or other annotations
  // \bobject\s+         -> Match the word 'object' (ensuring it's a boundary)
  // (\w+)               -> Capture the object name
  val robustRegex = """(?s)@AutoRegister\s*\(\s*"([^"]+)"\s*\)(?:[\s\w@\(\)."]*?)\bobject\s+(\w+)""".r
  val packageRegex = """(?m)^package\s+([\w\.]+)""".r


  val found = (sourceDir ** "*.scala").get.flatMap { file =>
    val content = IO.read(file)

    // Determine the package (defaulting to empty string if none found)
    val pkgPrefix = packageRegex.findFirstMatchIn(content)
      .map(_.group(1) + ".")
      .getOrElse("")

    robustRegex.findAllMatchIn(content).map { m =>
      val registryKey = m.group(1).trim
      val objectName  = m.group(2).trim
      val fqn         = pkgPrefix + objectName

      s""""$registryKey" -> $fqn"""
    }
  }.distinct

  val code =
    s"""package tempura.cozy
       |import tempura.cozy.Transforms.*
       |/////////////////////////////
       |/** AUTO-GENERATED BY SBT **/
       |object Registry {
       |  private val storage: Map[String, Transform[? <: Tuple, ? <: Tuple]] = Map(
       |    ${found.mkString(",\n    ")}
       |  )
       |
       |  def lookup(name: String): Option[Transform[? <: Tuple, ? <: Tuple]] = storage.get(name)
       |
       |  def getAllTransforms: Map[String, Transform[? <: Tuple, ? <: Tuple]] = storage
       |  def getAs[T](name: String): Option[T] =
       |    storage.get(name).map(_.asInstanceOf[T])
       |}
       |""".stripMargin

  if (!targetFile.exists() || IO.read(targetFile) != code) {
    IO.write(targetFile, code)
  }

  Seq(targetFile)
}

Compile / sourceGenerators += generateRegistry.taskValue

// Optional, required for the `source` command to work
(fullClasspath in Test) ++= {
  (updateClassifiers in Test).value
    .configurations
    .find(_.configuration.name == Test.name)
    .get
    .modules
    .flatMap(_.artifacts)
    .collect { case (a, f) if a.classifier == Some("sources") => f }
}


scalacOptions ++= Seq("-experimental")

lazy val root = (project in file("."))
  .settings(
    name := "Tempura"
  )